extern "C" {
    fn thorin_get_micro_time() -> i64;
    fn thorin_print_micro_time(i64) -> ();
}
fn range(a : int, b : int, yield : fn(int, fn())) -> () {
    if a < b {
        yield(a);
        range(a+1, b, yield, return)
    }
}
fn sort(num : int, mut arr : &[i64]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}

fn iteration(arr : &[float], out : &[float],
             body : fn(int, int, &[float], &[float]) -> ()
            ) -> () {
    let mut times = ~[7:i64];
    for i in @range(0, 7) {
        let start = thorin_get_micro_time();
        body(0, 0, arr, out);
        times(i) = thorin_get_micro_time()-start;
    }
    sort(7, times);
    thorin_print_micro_time(times(3));
}


// V-Cycle DSL: solver, etc. can be provided by the user
fn vcycle_dsl(levels : int) -> () {
    let mut Sol = ~[levels:&[float]];
    let mut Tmp = ~[levels:&[float]];

    fn vcycle_dsl_intern(level : int) -> () {
        if level == levels-1 {
            for x, y, mut tmp_acc, sol_acc in iteration(Tmp(level), Sol(level)) {
                tmp_acc(0) = sol_acc(0);
            }
        } else {
            vcycle_dsl_intern(level+1);
            Sol(level)(0) = Tmp(level)(0);
        }
    }
    vcycle_dsl_intern(0);
}

extern
fn thorin_vcycle(img_data : &[float], out_data : &[float], width : int, height : int) -> () {
    let result = @vcycle_dsl(4);
}

