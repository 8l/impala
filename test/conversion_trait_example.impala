trait Conv[T] {
	fn conv(&self) -> T;
}

trait Add {
	fn add(&self, x:Self) -> Self;
}

/////////////////////////////////////////////////

struct S { x : int }

impl Conv[int] for S {
	fn conv(&self) -> int { self.x }
}

impl Add for S {
	fn add(&self, s:S) -> S { S { x:(self.x + s.x) } }
}

impl Eq for S {
	fn eq(&self, o : &S) -> bool { self.x == o.x }
	fn ne(&self, o : &S) -> bool { self.x != o.x }
}

//////////////////////////////////////////////////

impl Conv[S] for int {
	fn conv(&self) -> S { S { x : *self } }
}

impl Add for int {
	fn add(&self, x:int) -> int { *self + x }
}

//////////////////////////////////////////////////

fn assertAddEqual[T:Eq+Add+Conv[U], U:Eq+Add+Conv[T]](t : T, u : U) -> bool {
	let a : T = t.add(u.conv());
	let b : U = u.add(t.conv());
	
	if ((a.conv() == b) && (b.conv() == a)) {
		true
	} else {
		false
	}
}

//////////////////////////////////////////////////

fn main() -> int {
	let s = S { x:5 };
	let t = 7;
	
	assertAddEqual(s, t) ? 0 : 1
}
