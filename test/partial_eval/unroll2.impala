extern array(int, int, int) -> [float];
extern free_array([float]) -> void;
extern random_val(int) -> float;

extern opencl(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern int64_to_int32(int64) -> int32;

fn iterate(a : int, b : int, yield : fn(int, fn())) -> void {
    let mut i: int = a;
    while (i < b)
        yield(i++, || { continue; });
}

// border handling specialization
fn clamp_lower(idx : int, lower : int) -> int {
    return idx < lower ? lower : idx;
}
fn clamp_upper(idx : int, upper : int) -> int {
    return idx >= upper ? upper - 1 : idx;
}
fn clamp_none(idx : int, bound : int) -> int {
    return idx;
}

intrinsic get_work_dim() -> int32;
intrinsic get_global_size(int32) -> int64;
intrinsic get_global_id(int32) -> int64;
intrinsic get_local_size(int32) -> int64;
intrinsic get_local_id(int32) -> int64;
intrinsic get_num_groups(int32) -> int64;
intrinsic get_group_id(int32) -> int64;
intrinsic get_global_offset(int32) -> int64;

fn iteration_bounds(width : int, height : int, range : int,
                    body : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // compute the number of blocks required for boundary handling
    let mut bhr = range / 2;
    if (bhr % unroll==0) bhr = bhr / unroll;
    else bhr = bhr / unroll + 1;
    let block = (128, bhr, 1);

    // bounds account for unroll factor
    let hu = height/unroll;
    let Bounds2D = [
        (0               , block[0]        , 0            , block[1]),
        (block[0]        , width - block[0], 0            , block[1]),
        (width - block[0], width           , 0            , block[1]),

        (0               , block[0]        , block[1]     , hu - block[1]),
        (block[0]        , width - block[0], block[1]     , hu - block[1]),
        (width - block[0], width           , block[1]     , hu - block[1]),

        (0               , block[0]        , hu - block[1], hu),
        (block[0]        , width - block[0], hu - block[1], hu),
        (width - block[0], width           , hu - block[1], hu)
    ];

    iterate(0, 9, |region : int| -> void {
        let bounds = Bounds2D[region];
        let dim = (bounds[1] - bounds[0], bounds[3] - bounds[2], 1);

        opencl(1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(tid_x + bounds[0], tid_y + bounds[2] * unroll + i * int64_to_int32(get_local_size(1)), region);
            });
        });
    });
}

fn apply_stencil(range : int, stencil : [float * 5 * 5],
                 x : int, y : int, arr : [float], width : int, height : int,
                 region: int
                ) -> float {
    let mut sum_xxx = 0.0f;
    let half_range = range / 2;

    iterate(-half_range, half_range+1, |j : int| -> void {
        iterate(-half_range, half_range+1, |i : int| -> void {
            let stencil_val = stencil[i + half_range][j + half_range];
            if (stencil_val != 0.0f) {
                let mut idx_x = x + i;
                let mut idx_y = y + j;

                // 0 --- 1 --- 2
                // 3 --- 4 --- 5
                // 6 --- 7 --- 8

                // left
                if (region == 0) idx_x = clamp_lower(idx_x, 0);
                if (region == 3) idx_x = clamp_lower(idx_x, 0);
                if (region == 6) idx_x = clamp_lower(idx_x, 0);

                // right
                if (region == 2) idx_x = clamp_upper(idx_x, width);
                if (region == 5) idx_x = clamp_upper(idx_x, width);
                if (region == 8) idx_x = clamp_upper(idx_x, width);

                // top
                if (region == 0) idx_y = clamp_lower(idx_y, 0);
                if (region == 1) idx_y = clamp_lower(idx_y, 0);
                if (region == 2) idx_y = clamp_lower(idx_y, 0);

                // bottom
                if (region == 6) idx_y = clamp_upper(idx_y, height);
                if (region == 7) idx_y = clamp_upper(idx_y, height);
                if (region == 8) idx_y = clamp_upper(idx_y, height);

                // all in
                if (region == 10) {
                    idx_x = clamp_lower(idx_x, 0);
                    idx_x = clamp_upper(idx_x, width);
                    idx_y = clamp_upper(idx_y, height);
                    idx_y = clamp_lower(idx_y, 0);
                }

                sum_xxx += arr[idx_y * width + idx_x] * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        });
    });

    return sum_xxx;
}

fn main() -> int {
    let width   = 4096;
    let height  = 4096;
    let range   = 5;
    let mut arr = array(4, width, height);
    let mut out = array(4, width, height);

    let stencil_sep : [float * 5] = [
          0.070766f, 0.244460f, 0.369546f, 0.244460f, 0.070766f ];

    let stencil : [float * 5 * 5] = [
        [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ],
        [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
        [ 0.026151f, 0.090339f, 0.136565f, 0.090339f, 0.026151f ],
        [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
        [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ]];


    // SS + BH
    @iteration_bounds($width, $height, range,
        |x : int, y : int, region : int| -> void {
            out[y*width + x] = apply_stencil(range, stencil, x, y, arr,
                                              $width, $height, region);
        }
    );

    free_array(arr);
    free_array(out);

    return 0;
}
